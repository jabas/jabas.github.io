{"version":3,"file":"bundle.mjs","mappings":";;;;;;;;;AAAA;AACA;AACA,KAAK,IAA0C;AAC/C,EAAE,iCAAO,CAAC,OAAS,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AAC9B,GAAG,KAAK,YAQN;AACF,CAAC;AACD;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,+BAA+B;AAC7E;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA,2CAA2C;;AAE3C;AACA,iCAAiC;;AAEjC;AACA,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;;AAEL;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA,qFAAqF,aAAa;AAClG;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,yFAAyF,eAAe;AACxG;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,yFAAyF,eAAe;AACxG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;;;;;;;;;ACpeD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA,wCAAwC;AACxC;AACA;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACgD;;AAEhD;;AAEA;AACA;AACA;AACA,uDAAqB;AACrB;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA,0BAA0B,mEAMtB,IAAa,OAAO,CACrB;AACH,CAAC;;AAED;AACA;AACA;AACA,qDAAmB;;;;;;;;;;;;;AC9BnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;;AAEA,+DAAe,WAAW,EAAC;;;;;;;UCxB3B;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA,eAAe,4BAA4B;WAC3C,eAAe;WACf,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA,8CAA8C;;;;;WCA9C;WACA;WACA;WACA;WACA,uBAAuB,4BAA4B;WACnD;WACA;WACA;WACA,iBAAiB,oBAAoB;WACrC;WACA,mGAAmG,YAAY;WAC/G;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,4CAA4C,mBAAmB;WAC/D;WACA;WACA;WACA,mEAAmE,iCAAiC;WACpG;WACA;WACA;WACA;;;;;WCzCA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;;;;;WCAA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,iCAAiC;;WAEjC;WACA;WACA;WACA,KAAK;WACL,eAAe;WACf;WACA,2DAA2D,oEAAoE;WAC/H;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,iCAAiC,mCAAmC;WACpE;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;WACA;WACA;;;;;;;;;;;;;;ACvFA;AACA;;AAEA;AACA;AACA;AACiC;AACA;;AAEjC;AACA","sources":["webpack://kumiko-product-language/./node_modules/conditioner-core/conditioner-core.js","webpack://kumiko-product-language/./src/_js/modules/ lazy ^\\.\\/.*$ chunkName: [request] namespace object","webpack://kumiko-product-language/./src/_js/utilities/conditioner.js","webpack://kumiko-product-language/./src/_js/utilities/setExtLinks.js","webpack://kumiko-product-language/webpack/bootstrap","webpack://kumiko-product-language/webpack/runtime/compat get default export","webpack://kumiko-product-language/webpack/runtime/define property getters","webpack://kumiko-product-language/webpack/runtime/ensure chunk","webpack://kumiko-product-language/webpack/runtime/get javascript chunk filename","webpack://kumiko-product-language/webpack/runtime/hasOwnProperty shorthand","webpack://kumiko-product-language/webpack/runtime/load script","webpack://kumiko-product-language/webpack/runtime/make namespace object","webpack://kumiko-product-language/webpack/runtime/publicPath","webpack://kumiko-product-language/webpack/runtime/jsonp chunk loading","webpack://kumiko-product-language/./src/_js/entry.js"],"sourcesContent":["/* conditioner-core 2.3.3 */\n(function (global, factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine(['exports'], factory);\n\t} else if (typeof exports !== \"undefined\") {\n\t\tfactory(exports);\n\t} else {\n\t\tvar mod = {\n\t\t\texports: {}\n\t\t};\n\t\tfactory(mod.exports);\n\t\tglobal.conditioner = mod.exports;\n\t}\n})(this, function (exports) {\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\n\tvar _slicedToArray = function () {\n\t\tfunction sliceIterator(arr, i) {\n\t\t\tvar _arr = [];\n\t\t\tvar _n = true;\n\t\t\tvar _d = false;\n\t\t\tvar _e = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t\t\t\t\t_arr.push(_s.value);\n\n\t\t\t\t\tif (i && _arr.length === i) break;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_d = true;\n\t\t\t\t_e = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_n && _i[\"return\"]) _i[\"return\"]();\n\t\t\t\t} finally {\n\t\t\t\t\tif (_d) throw _e;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn _arr;\n\t\t}\n\n\t\treturn function (arr, i) {\n\t\t\tif (Array.isArray(arr)) {\n\t\t\t\treturn arr;\n\t\t\t} else if (Symbol.iterator in Object(arr)) {\n\t\t\t\treturn sliceIterator(arr, i);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t\t\t}\n\t\t};\n\t}();\n\n\tfunction _toConsumableArray(arr) {\n\t\tif (Array.isArray(arr)) {\n\t\t\tfor (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n\t\t\t\tarr2[i] = arr[i];\n\t\t\t}\n\n\t\t\treturn arr2;\n\t\t} else {\n\t\t\treturn Array.from(arr);\n\t\t}\n\t}\n\n\t// links the module to the element and exposes a callback api object\n\tvar bindModule = function bindModule(element, unbind) {\n\t\t// gets the name of the module from the element, we assume the name is an alias\n\t\tvar alias = runPlugin('moduleGetName', element);\n\n\t\t// sets the name of the plugin, this does nothing by default but allows devs to turn an alias into the actual module name\n\t\tvar name = chainPlugins('moduleSetName', alias);\n\n\t\t// internal state\n\t\tvar state = {\n\t\t\tdestruct: null, // holder for unload method (function returned by module constructor)\n\t\t\tmounting: false\n\t\t};\n\n\t\t// api wrapped around module object\n\t\tvar boundModule = {\n\t\t\t// original name as found on the element\n\t\t\talias: alias,\n\n\t\t\t// transformed name\n\t\t\tname: name,\n\n\t\t\t// reference to the element the module is bound to\n\t\t\telement: element,\n\n\t\t\t// is the module currently mounted?\n\t\t\tmounted: false,\n\n\t\t\t// unmounts the module\n\t\t\tunmount: function unmount() {\n\t\t\t\t// can't be unmounted if no destroy method has been supplied\n\t\t\t\t// can't be unmounted if not mounted\n\t\t\t\tif (!state.destruct || !boundModule.mounted) return;\n\n\t\t\t\t// about to unmount the module\n\t\t\t\teachPlugins('moduleWillUnmount', boundModule);\n\n\t\t\t\t// clean up\n\t\t\t\tstate.destruct();\n\n\t\t\t\t// no longer mounted\n\t\t\t\tboundModule.mounted = false;\n\n\t\t\t\t// done unmounting the module\n\t\t\t\teachPlugins('moduleDidUnmount', boundModule);\n\n\t\t\t\t// done unmounting\n\t\t\t\tboundModule.onunmount.apply(element);\n\t\t\t},\n\n\t\t\t// requests and loads the module\n\t\t\tmount: function mount() {\n\t\t\t\t// can't mount an already mounted module\n\t\t\t\t// can't mount a module that is currently mounting\n\t\t\t\tif (boundModule.mounted || state.mounting) return;\n\n\t\t\t\t// now mounting module\n\t\t\t\tstate.mounting = true;\n\n\t\t\t\t// about to mount the module\n\t\t\t\teachPlugins('moduleWillMount', boundModule);\n\n\t\t\t\t// get the module\n\t\t\t\trunPlugin('moduleImport', name).then(function (module) {\n\t\t\t\t\t// initialise the module, module can return a destroy mehod\n\t\t\t\t\tstate.destruct = runPlugin('moduleGetDestructor', runPlugin('moduleGetConstructor', module).apply(undefined, _toConsumableArray(runPlugin('moduleSetConstructorArguments', name, element))));\n\n\t\t\t\t\t// no longer mounting\n\t\t\t\t\tstate.mounting = false;\n\n\t\t\t\t\t// module is now mounted\n\t\t\t\t\tboundModule.mounted = true;\n\n\t\t\t\t\t// did mount the module\n\t\t\t\t\teachPlugins('moduleDidMount', boundModule);\n\n\t\t\t\t\t// module has now loaded lets fire the onload event so everyone knows about it\n\t\t\t\t\tboundModule.onmount.apply(element, [boundModule]);\n\t\t\t\t}).catch(function (error) {\n\t\t\t\t\t// failed to mount so no longer mounting\n\t\t\t\t\tstate.mounting = false;\n\n\t\t\t\t\t// failed to mount the module\n\t\t\t\t\teachPlugins('moduleDidCatch', error, boundModule);\n\n\t\t\t\t\t// callback for this specific module\n\t\t\t\t\tboundModule.onmounterror.apply(element, [error, boundModule]);\n\n\t\t\t\t\t// let dev know\n\t\t\t\t\tthrow new Error('Conditioner: ' + error);\n\t\t\t\t});\n\n\t\t\t\t// return state object\n\t\t\t\treturn boundModule;\n\t\t\t},\n\n\t\t\t// unmounts the module and destroys the attached monitors\n\t\t\tdestroy: function destroy() {\n\n\t\t\t\t// about to destroy the module\n\t\t\t\teachPlugins('moduleWillDestroy', boundModule);\n\n\t\t\t\t// not implemented yet\n\t\t\t\tboundModule.unmount();\n\n\t\t\t\t// did destroy the module\n\t\t\t\teachPlugins('moduleDidDestroy', boundModule);\n\n\t\t\t\t// call public ondestroy so dev can handle it as well\n\t\t\t\tboundModule.ondestroy.apply(element);\n\n\t\t\t\t// call the destroy callback so monitor can be removed as well\n\t\t\t\tunbind();\n\t\t\t},\n\n\t\t\t// called when fails to bind the module\n\t\t\tonmounterror: function onmounterror() {},\n\n\t\t\t// called when the module is loaded, receives the state object, scope is set to element\n\t\t\tonmount: function onmount() {},\n\n\t\t\t// called when the module is unloaded, scope is set to element\n\t\t\tonunmount: function onunmount() {},\n\n\t\t\t// called when the module is destroyed\n\t\t\tondestroy: function ondestroy() {}\n\t\t};\n\n\t\t// done!\n\t\treturn boundModule;\n\t};\n\n\tvar queryParamsRegex = /(was)? ?(not)? ?@([a-z]+) ?(.*)?/;\n\tvar queryRegex = /(?:was )?(?:not )?@[a-z]+ ?.*?(?:(?= and (?:was )?(?:not )?@[a-z])|$)/g;\n\n\t// convert context values to booleans if value is undefined or a boolean described as string\n\tvar toContextValue = function toContextValue(value) {\n\t\treturn typeof value === 'undefined' || value === 'true' ? true : value === 'false' ? false : value;\n\t};\n\n\tvar extractParams = function extractParams(query) {\n\t\tvar _query$match = query.match(queryParamsRegex),\n\t\t    _query$match2 = _slicedToArray(_query$match, 5),\n\t\t    retain = _query$match2[1],\n\t\t    invert = _query$match2[2],\n\t\t    name = _query$match2[3],\n\t\t    value = _query$match2[4];\n\n\t\t// extract groups, we ignore the first array index which is the entire matches string\n\t\treturn [name, toContextValue(value), invert === 'not', retain === 'was'];\n\t};\n\n\t// @media (min-width:30em) and was @visible true  ->  [ ['media', '(min-width:30em)', false, false], ['visible', 'true', false, true] ]\n\tvar parseQuery = function parseQuery(query) {\n\t\treturn query.match(queryRegex).map(extractParams);\n\t};\n\n\t// add intert and retain properties to monitor\n\tvar decorateMonitor = function decorateMonitor(monitor, invert, retain) {\n\t\tmonitor.invert = invert;\n\t\tmonitor.retain = retain;\n\t\tmonitor.matched = false;\n\t\treturn monitor;\n\t};\n\n\t// finds monitor plugins and calls the create method on the first found monitor\n\tvar getContextMonitor = function getContextMonitor(element, name, context) {\n\t\tvar monitor = getPlugins('monitor').find(function (monitor) {\n\t\t\treturn monitor.name === name;\n\t\t});\n\t\t// @exclude\n\t\tif (!monitor) {\n\t\t\tthrow new Error('Conditioner: Cannot find monitor with name \"@' + name + '\". Only the \"@media\" monitor is always available. Custom monitors can be added with the `addPlugin` method using the `monitors` key. The name of the custom monitor should not include the \"@\" symbol.');\n\t\t}\n\t\t// @endexclude\n\t\treturn monitor.create(context, element);\n\t};\n\n\t// test if monitor contexts are currently valid\n\tvar matchMonitors = function matchMonitors(monitors) {\n\t\treturn monitors.reduce(function (matches, monitor) {\n\t\t\t// an earlier monitor returned false, so current context will no longer be suitable\n\t\t\tif (!matches) return false;\n\n\t\t\t// get current match state, takes \"not\" into account\n\t\t\tvar matched = monitor.invert ? !monitor.matches : monitor.matches;\n\n\t\t\t// mark monitor as has been matched in the past\n\t\t\tif (matched) monitor.matched = true;\n\n\t\t\t// if retain is enabled with \"was\" and the monitor has been matched in the past, there's a match\n\t\t\tif (monitor.retain && monitor.matched) return true;\n\n\t\t\t// return current match state\n\t\t\treturn matched;\n\t\t},\n\n\t\t// initial value is always match\n\t\ttrue);\n\t};\n\n\tvar monitor = exports.monitor = function monitor(query, element) {\n\t\t// setup monitor api\n\t\tvar contextMonitor = {\n\t\t\tmatches: false,\n\t\t\tactive: false,\n\t\t\tonchange: function onchange() {},\n\t\t\tstart: function start() {\n\t\t\t\t// cannot be activated when already active\n\t\t\t\tif (contextMonitor.active) return;\n\n\t\t\t\t// now activating\n\t\t\t\tcontextMonitor.active = true;\n\n\t\t\t\t// listen for context changes\n\t\t\t\tmonitorSets.forEach(function (monitorSet) {\n\t\t\t\t\treturn monitorSet.forEach(function (monitor) {\n\t\t\t\t\t\treturn monitor.addListener(onMonitorEvent);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\t// get initial state\n\t\t\t\tonMonitorEvent();\n\t\t\t},\n\t\t\tstop: function stop() {\n\t\t\t\t// disable the monitor\n\t\t\t\tcontextMonitor.active = false;\n\n\t\t\t\t// disable\n\t\t\t\tmonitorSets.forEach(function (monitorSet) {\n\t\t\t\t\treturn monitorSet.forEach(function (monitor) {\n\t\t\t\t\t\t// stop listening (if possible)\n\t\t\t\t\t\tif (!monitor.removeListener) return;\n\t\t\t\t\t\tmonitor.removeListener(onMonitorEvent);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tdestroy: function destroy() {\n\t\t\t\tcontextMonitor.stop();\n\t\t\t\tmonitorSets.length = 0;\n\t\t\t}\n\t\t};\n\n\t\t// get different monitor sets (each 'or' creates a separate monitor set) > get monitors for each query\n\t\tvar monitorSets = query.split(' or ').map(function (subQuery) {\n\t\t\treturn parseQuery(subQuery).map(function (params) {\n\t\t\t\treturn decorateMonitor.apply(undefined, [getContextMonitor.apply(undefined, [element].concat(_toConsumableArray(params)))].concat(_toConsumableArray(params.splice(2))));\n\t\t\t});\n\t\t});\n\n\t\t// if all monitors return true for .matches getter, we mount the module\n\t\tvar onMonitorEvent = function onMonitorEvent() {\n\t\t\t// will keep returning false if one of the monitors does not match, else checks matches property\n\t\t\tvar matches = monitorSets.reduce(function (matches, monitorSet) {\n\t\t\t\treturn (\n\t\t\t\t\t// if one of the sets is true, it's all fine, no need to match the other sets\n\t\t\t\t\tmatches ? true : matchMonitors(monitorSet)\n\t\t\t\t);\n\t\t\t}, false);\n\n\t\t\t// store new state\n\t\t\tcontextMonitor.matches = matches;\n\n\t\t\t// if matches we mount the module, else we unmount\n\t\t\tcontextMonitor.onchange(matches);\n\t\t};\n\n\t\treturn contextMonitor;\n\t};\n\n\t// handles contextual loading and unloading\n\tvar createContextualModule = function createContextualModule(query, boundModule) {\n\t\t// setup query monitor\n\t\tvar moduleMonitor = monitor(query, boundModule.element);\n\t\tmoduleMonitor.onchange = function (matches) {\n\t\t\treturn matches ? boundModule.mount() : boundModule.unmount();\n\t\t};\n\n\t\t// start monitoring\n\t\tmoduleMonitor.start();\n\n\t\t// export monitor\n\t\treturn moduleMonitor;\n\t};\n\n\t// pass in an element and outputs a bound module object, will wrap bound module in a contextual module if required\n\tvar createModule = function createModule(element) {\n\n\t\t// called when the module is destroyed\n\t\tvar unbindModule = function unbindModule() {\n\t\t\treturn monitor && monitor.destroy();\n\t\t};\n\n\t\t// bind the module to the element and receive the module wrapper API\n\t\tvar boundModule = bindModule(element, unbindModule);\n\n\t\t// get context requirements for this module (if any have been defined)\n\t\tvar query = runPlugin('moduleGetContext', element);\n\n\t\t// wait for the right context or load the module immidiately if no context supplied\n\t\tvar monitor = query && createContextualModule(query, boundModule);\n\n\t\t// return module\n\t\treturn query ? boundModule : boundModule.mount();\n\t};\n\n\t// parse a certain section of the DOM and load bound modules\n\tvar hydrate = exports.hydrate = function hydrate(context) {\n\t\treturn [].concat(_toConsumableArray(runPlugin('moduleSelector', context))).map(createModule);\n\t};\n\n\t// all registered plugins\n\tvar plugins = [];\n\n\t// array includes 'polyfill', Array.prototype.includes was the only feature not supported on Edge\n\tvar includes = function includes(arr, value) {\n\t\treturn arr.indexOf(value) > -1;\n\t};\n\n\t// plugins are stored in an array as multiple plugins can subscribe to one hook\n\tvar addPlugin = exports.addPlugin = function addPlugin(plugin) {\n\t\treturn plugins.push(plugin);\n\t};\n\n\t// returns the plugins that match the requested type, as plugins can subscribe to multiple hooks we need to loop over the plugin keys to see if it matches\n\tvar getPlugins = function getPlugins(type) {\n\t\treturn plugins.filter(function (plugin) {\n\t\t\treturn includes(Object.keys(plugin), type);\n\t\t}).map(function (plugin) {\n\t\t\treturn plugin[type];\n\t\t});\n\t};\n\n\t// run for each of the registered plugins\n\tvar eachPlugins = function eachPlugins(type) {\n\t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t\targs[_key - 1] = arguments[_key];\n\t\t}\n\n\t\treturn getPlugins(type).forEach(function (plugin) {\n\t\t\treturn plugin.apply(undefined, args);\n\t\t});\n\t};\n\n\t// run registered plugins but chain input -> output (sync)\n\tvar chainPlugins = function chainPlugins(type) {\n\t\tfor (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t\t\targs[_key2 - 1] = arguments[_key2];\n\t\t}\n\n\t\treturn getPlugins(type).reduce(function (args, plugin) {\n\t\t\treturn [plugin.apply(undefined, _toConsumableArray(args))];\n\t\t}, args).shift();\n\t};\n\n\t// run on last registered plugin\n\tvar runPlugin = function runPlugin(type) {\n\t\tfor (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n\t\t\targs[_key3 - 1] = arguments[_key3];\n\t\t}\n\n\t\treturn getPlugins(type).pop().apply(undefined, args);\n\t};\n\n\t// default plugin configuration\n\taddPlugin({\n\t\t// select all elements that have modules assigned to them\n\t\tmoduleSelector: function moduleSelector(context) {\n\t\t\treturn context.querySelectorAll('[data-module]');\n\t\t},\n\n\t\t// returns the context query as defined on the element\n\t\tmoduleGetContext: function moduleGetContext(element) {\n\t\t\treturn element.dataset.context;\n\t\t},\n\n\t\t// load the referenced module, by default searches global scope for module name\n\t\tmoduleImport: function moduleImport(name) {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tif (self[name]) return resolve(self[name]);\n\t\t\t\t// @exclude\n\t\t\t\treject('Cannot find module with name \"' + name + '\". By default Conditioner will import modules from the global scope, make sure a function named \"' + name + '\" is defined on the window object. The scope of a function defined with `let` or `const` is limited to the <script> block in which it is defined.');\n\t\t\t\t// @endexclude\n\t\t\t});\n\t\t},\n\n\t\t// returns the module constructor, by default we assume the module returned is a factory function\n\t\tmoduleGetConstructor: function moduleGetConstructor(module) {\n\t\t\treturn module;\n\t\t},\n\n\t\t// returns the module destrutor, by default we assume the constructor exports a function\n\t\tmoduleGetDestructor: function moduleGetDestructor(moduleExports) {\n\t\t\treturn moduleExports;\n\t\t},\n\n\t\t// arguments to pass to the module constructor as array\n\t\tmoduleSetConstructorArguments: function moduleSetConstructorArguments(name, element) {\n\t\t\treturn [element];\n\t\t},\n\n\t\t// where to get name of module\n\t\tmoduleGetName: function moduleGetName(element) {\n\t\t\treturn element.dataset.module;\n\t\t},\n\n\t\t// default media query monitor\n\t\tmonitor: {\n\t\t\tname: 'media',\n\t\t\tcreate: function create(context) {\n\t\t\t\treturn self.matchMedia(context);\n\t\t\t}\n\t\t}\n\t});\n});","var map = {\n\t\"./ui/test\": [\n\t\t\"./src/_js/modules/ui/test.js\",\n\t\t\"ui-test\"\n\t],\n\t\"./ui/test.js\": [\n\t\t\"./src/_js/modules/ui/test.js\",\n\t\t\"ui-test\"\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn __webpack_require__.e(ids[1]).then(function() {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = function() { return Object.keys(map); };\nwebpackAsyncContext.id = \"./src/_js/modules lazy recursive ^\\\\.\\\\/.*$\";\nmodule.exports = webpackAsyncContext;","/**\n * Import conditioner\n * As per: https://pqina.nl/conditioner/\n */\nimport * as conditioner from 'conditioner-core';\n\n/* prettier-ignore */\n\n/**\n * Configure conditioner to work with dynamic imports & webpack\n */\nconditioner.addPlugin({\n  // converts module aliases to paths\n  moduleSetName: (name) => `${name}.js`,\n  // get the module constructor\n  moduleGetConstructor: (module) => module.default,\n  // override the import\n  moduleImport: (name) => import(\n    /* https://webpack.js.org/api/module-methods/#import- */\n    /* set to \"eager\" to create a single chunk for all modules */\n    /* set to \"lazy\" to create a separate chunk for each module */\n    /* webpackChunkName: \"[request]\" */\n    /* webpackMode: \"lazy\" */\n    '../modules/' + name // eslint-disable-line\n  ),\n});\n\n/**\n * Fire up the modules!\n */\nconditioner.hydrate(document.documentElement);\n","/**\n * Handles external links based on target=\"_blank\"\n *\n * Adds rel=\"noopener\" to the external links as per:\n * https://jakearchibald.com/2016/performance-benefits-of-rel-noopener/\n */\n\nconst setExtLinks = {\n  init: (context = document) => {\n    const links = context.querySelectorAll('a[target=\"_blank\"]');\n    setExtLinks.initAll(links);\n  },\n\n  initAll: (links) => {\n    if (links) {\n      [...links].forEach((link) => {\n        link.setAttribute('rel', 'noopener');\n      });\n    }\n  },\n};\n\nsetExtLinks.init();\n\nexport default setExtLinks;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".mjs\";\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","var inProgress = {};\nvar dataWebpackPrefix = \"kumiko-product-language:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = function(url, done, key, chunkId) {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = function(prev, event) {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach(function(fn) { return fn(event); });\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/js/\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"bundle\": 0\n};\n\n__webpack_require__.f.j = function(chunkId, promises) {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = function(event) {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkkumiko_product_language\"] = self[\"webpackChunkkumiko_product_language\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","/* your global dependencies */\n// import 'MODULE_FROM_NPM';\n\n/**\n * Utilities\n */\nimport './utilities/conditioner';\nimport './utilities/setExtLinks';\n\n/* your components */\n// import './components/YOUR_MODULE';\n"],"names":[],"sourceRoot":""}